#! /usr/bin/env perl 
use strict;
use JSON;
use File::Slurp;
use Data::Dumper;
use Getopt::Long;
use gjoseqlib;
use Digest::MD5 qw(md5_hex);


my $usage = 'uniprot_JSON_to_subseqs.pl <UniProt.JSON>Output.fasta or table
        
        -h   help
        -f   fasta output (default = table)
        	 Table format returns:
        -k   keep only subsequences with feature ids, 
             these tend to be "chains" e.g. mat peptides does not include the base sequence.
        -l   min length for a sub_sequence to be kept [d = 1 AA] 
        -n   do not print header
        
        The program returns a table or fasta of all the 
        protein subsequences annotated by uniprot within the json file.  

      	The input json can be generated by curling directly from uniprot or by using 
      	download_uniprot_fasta.pl with the -j flag.
      	
      	The output table has the following columns:
      	1.  Subseq id
      	2.  Subseq type
      	3.  Subseq description
      	4.  Subseq ligand_name
      	6.  Pubmed ID
      	7.  Start
      	8.  End
        9.  Source (in this case it copies base entry type)
        10. Primary accession (base_accession)
      	11. Secondary accession (base_uniprot_acc)
      	12. base_entry_type
      	13. base_prot_anno
      	14. base_prot_abv
      	15. organism
      	16. organism_abv
      	17. taxid
      	18. taxonomy
      	19. Subseq MD5
      	20. Subseq 	
      	21. Base Sequence MD5
      	22. Base Sequence

      	Note that start, end, and subseq will not be returned unless their start and end modifiers are listed as "exact"
        	 
';
my $min_len = 1;
my ($help, $fasta, $keep_chain, $noheader);

GetOptions(
    'h'    => \$help,
    'f'    => \$fasta,
    'k'    => \$keep_chain,
    'l=i'  => \$min_len,
    'n'    => \$noheader
) or die "$usage\n";

if ($help){die "$usage\n";}

#read the JSON
my $json_text = read_file(\*STDIN);
my $data = decode_json($json_text);
my $num_results = scalar @{$data->{results}};

unless ($fasta)
{
	print "Prot_Feat_ID\tProt_Feat_Type\tProt_Feat_Desc\tLigand_Name\tPubMedID\tStart\tEnd\tSource\tPrimary_Accession\tSedondary_Accession\tBase_Entry_Type\tBase_Prot_Anno\tBase_Prot_Abv\tOrganism\tOrganism_Abv\tTaxId\tTax\tSubSeq_MD5\tSubSeq\tBaseSeq_MD5\tBaseSeq\n"; 	
}

for (my $i = 0; $i < $num_results; $i++) 
{
    my $features = $data->{results}->[$i]->{features};
	my $num_features   = scalar @$features;
	
	#get data on the original sequence:
	my $base_sequence    = $data->{results}->[$i]->{sequence}->{value};
	my $base_accession   = $data->{results}->[$i]->{primaryAccession};
	my $base_uniprot_acc = $data->{results}->[$i]->{uniProtkbId};
	my $base_entry_type  = $data->{results}->[$i]->{entryType};
	my $base_prot_anno   = $data->{results}->[$i]->{proteinDescription}->{recommendedName}->{fullName}->{value};
	my $base_prot_abv    = $data->{results}->[$i]->{proteinDescription}->{recommendedName}->{shortNames}->[0]->{value};
	my $organism         = $data->{results}->[$i]->{organism}->{scientificName};
	my $organism_abv     = $data->{results}->[$i]->{organism}->{commonName};
	my $taxid            = $data->{results}->[$i]->{organism}->{taxonId};
	my $taxonomy         = join(";", @{$data->{results}->[$i]->{organism}->{lineage}});
	my $base_md5         = md5_hex(uc($base_sequence));

	
#	#get interpro ID
#	my $externaldb = $data->{results}->[$i]->{uniProtKBCrossReferences};
#	my $nexternal = 1;
#	my $interpro = "none";
#	my $interpro_des = "none";
#
#	if (ref($data->{results}->[$i]->{uniProtKBCrossReferences}) eq 'ARRAY') 
#   	{
#        $nexternal = scalar @{$data->{results}->[$i]->{uniProtKBCrossReferences}};
#    } 	
#	for (my $n = 0; $n < $nexternal; $n++) 
#	{
#		if ($externaldb->[$n]->{database} =~ /InterPro/)
#		{
#			$interpro     = $externaldb->[$n]->{id};
#			$interpro_des = $externaldb->[$n]->{properties}->[0]->{value};
#		}	
#	}



	for (my $j = 0; $j < $num_features; $j++) 
	{
		my $type           = $features->[$j]->{type};
		my $desc           = $features->[$j]->{description};
		my $id             = $features->[$j]->{featureId};
		my $start          = $features->[$j]->{location}->{start}->{value};
		my $start_modifier = $features->[$j]->{location}->{start}->{modifier};
		my $end            = $features->[$j]->{location}->{end}->{value};
		my $end_modifier   = $features->[$j]->{location}->{end}->{modifier};
		my $ligand_name    = $features->[$j]->{ligand}->{name};
		
		
		if (!$id){$id = "none";}
		if (!$desc){$desc = "none";}
		if (!$ligand_name){$ligand_name = "none";}
				
		my $num_evidences = 0;
   		if (ref($features->[$j]->{evidences}) eq 'ARRAY') 
   		{
        	$num_evidences = scalar @{$features->[$j]->{evidences}};
    	} 
    	elsif (ref($features->[$j]->{evidences}) eq 'HASH') 
    	{
        	$num_evidences = 1;
   		} 
		
		my @pmid = ();
		for (my $k = 0; $k < $num_evidences; $k++) 
		{
			if ($features->[$j]->{evidences}->[$k]->{source} =~ /PubMed/i)
			{
				push @pmid, $features->[$j]->{evidences}->[$k]->{id};
			}
		}
		my $pubmed = "none";
		if (@pmid){$pubmed = join (";", @pmid);}
		
		#Okay, now I am going to provide the sequence (even if it is one AA) for the corresponding protein feature.
		my $subseq = "not an exact modifier";
		my $subseq_md5;
		if (($start_modifier =~ /EXACT/i) && ($end_modifier =~ /EXACT/i))
		{
			my $length = ($end - ($start - 1)); 
			
			$subseq = substr($base_sequence, ($start - 1), $length);
			$subseq_md5 = md5_hex(uc($subseq));
		}
		my $len = length $subseq;

		if ((! $fasta) && (! $noheader))
		{
			print "$id\t$type\t$desc\t$ligand_name\t$pubmed\t$start\t$end\t$base_entry_type\t$base_accession\t$base_uniprot_acc\t$base_entry_type\t$base_prot_anno\t$base_prot_abv\t$organism\t$organism_abv\t$taxid\t$taxonomy\t$subseq_md5\t$subseq\t$base_md5\t$base_sequence\n"; 	
		}
		elsif (($fasta) && ($keep_chain) && ($id !~ /none/i) && ($len >= $min_len) && ($subseq !~ /not an exact modifier/))
		{
			my $header = "$desc   [$organism]";
			&gjoseqlib::print_alignment_as_fasta([$id, $header, $subseq]);
		}
		elsif (($fasta) && (! $keep_chain) && ($len >= $min_len) && ($subseq !~ /not an exact modifier/))
		{
			# try to figure out which info to show.
			my $new_id = $base_accession."_".($j+1);
			my @headers = ($id, $desc, $type, $ligand_name);
			my $header = "";
			foreach (@headers)
			{
				unless ($_ =~ /none/i)
				{
					$header .= "$_ ";
				}
			}
			$header .= "  [$organism]";
			&gjoseqlib::print_alignment_as_fasta([$new_id, $header, $subseq]);
		}
	}
}






























